## 一. 数据，变量，内存

* 数据：存储在内存中代表特定信息的东西，本质上是0101...
* 内存
  * 内存条通电后产生的可存储数据的空间（临时的）
  * 内存产生和死亡：内存条（电路板）-> 通电 -> 产生内存空间 -> 存储数据 ->处理数据 -> 断电 -> 内存空间和数据消失
  * 内存分类
    * 栈：全局变量和局部变量
    * 堆：对象
* 变量
  * 可变化的量（由变量名和变量值组成）。每个变量都对应一块小内存。变量名用来查找对应的内存，变量值就是内存中保存的数据。

## 二. 原型

* instanceof：实例对象A instanceof 构造函数B   如果B函数的显示原型对象在A对象的原型链上，返回ture 

## 三.  执行上下文

**注意函数是一等公民，函数声明先于变量声明提升，且无法覆盖。**

执行上下文有三个重要属性：

* 变量对象（VO）：变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明
* 作用域链（Scope chain）
* this

**变量对象：**全局上下文中的变量对象就是全局对象。但在函数上下文中，用活动对象（AO）来表示变量对象。

### 3.1 全局执行上下文

在执行全局代码时需要做的准备工作

* 在执行全局代码前将window确定为全局执行上下文
* 对全局数据进行预处理
  * function声明的全局函数 ==> 赋值（fun），添加为window方法
  * 用var定义的全局变量 ==> undefined，添加为window属性
  * this ==> 赋值（window）
* 开始执行全局代码

### 3.2 函数执行上下文

在调用函数，准备执行函数体之前，创建对应的函数执行上下文对象（虚拟对象），栈内存里划分了全局区域和函数区域，执行函数时，会为其分配栈内存。

* 对局部数据进行预处理
  * 形参变量 ==> 赋值（实参） == > 添加为执行上下文的属性
  * arguments ==> 赋值（实参列表），添加为执行上下文的属性
  * function声明的函数 == > 赋值（fun），添加为执行上下文的方法
  * var定义的局部变量 ==> undefined，添加为执行上下文属性
  * this ==> 赋值（调用该函数的对象）

* 开始执行函数体代码



## 四. 执行上下文栈

用于管理执行上下文对象的栈。

* 在全局代码执行前，JS引擎会创建一个栈来存储管理所有的执行上下文对象

* 在全局执行上下文（window）确定后，将其添加到栈中

* 在函数执行上下文穿件后，将其添加到栈中

* 在当前函数执行完后，将栈顶的对象移除

* 当所有的代码执行完后，栈中只剩window



## 五. 作用域和作用域链

**作用：**隔离变量，不同作用域下同名变量不会有冲突

**作用域和执行上下文区别：**

* 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定，而不是调用时。

* 全局执行上下文环境是在全局作用域确定之后，js代码马上执行之前创建

* 函数执行上下文环境h是在调用函数时，函数体代码执行之前创建。

* 作用域是静态的，只要函数定义好了就一直存在，且不会在变化
* 执行上下文是动态的，调用函数时创建，函数调用结束时上下文环境就会被释放



**作用域和执行上下文的联系：**

* 上下文环境是从属于所在的作用域
* 全局上下文环境 ==> 全局作用于
* 函数上下文环境 ==> 对应的函数作用域



## 六. 闭包

当一个嵌套的内部（子）函数引用了嵌套的外部（父）函数的变量时，就产生了闭包。

* 如何形成闭包

* 闭包的生命周期

**缺点：**

* 函数执行完后，函数内的局部变量没有释放，占用内存时间会变长
* 容易造成内存泄漏
  * 内存泄漏（本来可以有更大的内存可用，但由于内存泄漏，可用的变小了）
    * 占用的内存没有及时释放
    * 内存泄漏积累多了就容易导致内存溢出
    * 常见的内存泄漏
      * 意外的全局变量
      * 没有及时清理的计时器或回调函数
      * 闭包
  * 内存溢出
    * 一种程序运行出现的错误
    * 当程序运行需要的内存超过了剩余的内存时，就会抛出内存溢出的错误

**解决：**

* 能不用闭包就不用
* 及时释放（f = null，让内部函数成为垃圾对象==>回收闭包）



## 七. 线程机制和事件机制

### 7.1 进程与线程

* 进程：程序的一次执行，他占有的独有的内存空间，可以通过windows任务管理器查看进程
* 线程
  * 是进程内的一个独立执行单元
  * 是程序执行的一个完整流程
  * 是cpu最小的调度单元

**进程与线程相关知识**

* 应用程序必须运行在某个进程的某个线程上
* 一个进程至少有一个运行的线程：主线程，进程启动后自动创建
* 一个进程中也可以同时运行多个线程，我们会说程序是多线程运行的
* 一个进程内的数据可以供其中的多个线程直接共享
* 多个进程之间的数据不能直接共享
* 线程池（thread pool）：保存多个线程对象的容器，实现线程对象的反复利用

**进程与线程相关问题**

* 何为多进程与多线程
  * 多进程运行：一应用程序可以同时启动多个实例运行
  * 多线程：现在一个进程内，同时有多个线程运行
* 比较单线程和多线程
  * 多线程：
    * 优点：有效提高cpu利用率
    * 缺点：创建多线程开销，线程间切换开销，死锁与状态同步问题
  * 单线程：
    * 优点：顺序编程简单易懂
    * 缺点：效率低
* JS是单线程运行，但使用H5中的web workers可以多线程运行
* 浏览器运行是单线程还是多线程？
  * 都是多线程运行的
* 浏览器运行是单进程还是多进程？
  * 有单进程也有多进程
  * 如何查看是否多进程？看任务管理器

### 7.2 浏览器内核

* 支撑浏览器运行的最核心的程序
* 不同浏览器可能不一样：
  * Chrome,Safari:webkit
  * firefox:Gecko
  * IE:Trident
  * 360,搜狗等国内浏览器：trident + webkit
* 内核由很多模块组成
  * 主线程
    * js引擎模块：负责js程序的编译与运行
    * html，css文档解析模块：负责页面文本的解析
    * DOM/CSS模块：负责dom/css在内存中的相关处理
    * 布局和渲染模块：负责页面的布局和效果的绘制（内存中的对象）
  * 分线程
    * 定时器模块：负责定时器的管理
    * DOM事件响应模块：负责事件的管理
    * 网络请求模块：负责ajax请求

### 7.3 定时器引发的思考

定时器并不能保证真正定时进行。比如

```javascript
var start = new Date().getTime()
console.log('定时器启动时是：',start);
setTimeout(() => {
    console.log('执行了',Date.now() - start);
},200)

//长时间工作
for(var i = 0; i < 1000000000; i++){

}
```

此时，setTimeout内部执行的时间会远大于200ms



### 7.4 JS是单线程的

```javascript
setTimeout(() => {
      console.log(11111);
    },3000)
    setTimeout(() => {
      console.log(22222);
      alert('++++++')
    },1000)
    console.log('alert之前');
    alert('-------');
    console.log('aletr之后');
```

**代码分类**

* 初始化代码
* 回调代码

**js引擎执行代码的基本流程**

* 先执行初始化代码：包含一些特别的代码
  * 设置定时器
  * 绑定监听
  * 发送ajax请求
* 后面在某个时刻才会执行回调代码

### 7.5 事件循环模型



## 八. H5 web workers 多线程

Web Workers是HTML5提供的一个JavaScript多线程解决方案。

可以将一些大计算量的代码交由web workers运行而不冻结用户界面

但是子线程完全受主线程控制，且不得操作DOM。所以这个新标准并没有改变JavaScript单线程的本质。

### 8.1 使用

创建在分线程执行的js文件